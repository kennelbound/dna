<html>
<head>
    <script type="text/javascript" src="../dist/index_bundle.js"></script>
    <script type="text/javascript" src="./genome1.js"></script>
    <script type="text/javascript" src="../node_modules/three/build/three.min.js"></script>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            background-color: #000000;
            margin: 0px;
            overflow: hidden;
        }

        a {
            color: #0078ff;
        }

        a {
            color: orange;
            text-decoration: none;
        }

        a:hover {
            color: #0080ff;
        }
    </style>
</head>
<body>
<script type="text/javascript">
    /**
     * Hilbert Curve: Generates 2D-Coordinates in a very fast way.
     *
     * @author Dylan Grafmyre
     *
     * Based on work by:
     * @author Thomas Diewald
     * @link http://www.openprocessing.org/visuals/?visualID=15599
     *
     * Based on `examples/canvas_lines_colors.html`:
     * @author OpenShift guest
     * @link https://github.com/mrdoob/three.js/blob/8413a860aa95ed29c79cbb7f857c97d7880d260f/examples/canvas_lines_colors.html
     * @see  Line 149 - 186
     *
     * @param center     Center of Hilbert curve.
     * @param size       Total width of Hilbert curve.
     * @param iterations Number of subdivisions.
     * @param v0         Corner index -X, +Y, -Z.
     * @param v1         Corner index -X, +Y, +Z.
     * @param v2         Corner index -X, -Y, +Z.
     * @param v3         Corner index -X, -Y, -Z.
     * @param v4         Corner index +X, -Y, -Z.
     * @param v5         Corner index +X, -Y, +Z.
     * @param v6         Corner index +X, +Y, +Z.
     * @param v7         Corner index +X, +Y, -Z.
     */
    function hilbert3D(center, size, iterations, v0, v1, v2, v3, v4, v5, v6, v7) {

        // Default Vars
        var center = undefined !== center ? center : new THREE.Vector3(0, 0, 0),
            size = undefined !== size ? size : 10,
            half = size / 2,
            iterations = undefined !== iterations ? iterations : 1,
            v0 = undefined !== v0 ? v0 : 0,
            v1 = undefined !== v1 ? v1 : 1,
            v2 = undefined !== v2 ? v2 : 2,
            v3 = undefined !== v3 ? v3 : 3,
            v4 = undefined !== v4 ? v4 : 4,
            v5 = undefined !== v5 ? v5 : 5,
            v6 = undefined !== v6 ? v6 : 6,
            v7 = undefined !== v7 ? v7 : 7
        ;

        var vec_s = [
            new THREE.Vector3(center.x - half, center.y + half, center.z - half),
            new THREE.Vector3(center.x - half, center.y + half, center.z + half),
            new THREE.Vector3(center.x - half, center.y - half, center.z + half),
            new THREE.Vector3(center.x - half, center.y - half, center.z - half),
            new THREE.Vector3(center.x + half, center.y - half, center.z - half),
            new THREE.Vector3(center.x + half, center.y - half, center.z + half),
            new THREE.Vector3(center.x + half, center.y + half, center.z + half),
            new THREE.Vector3(center.x + half, center.y + half, center.z - half)
        ];

        var vec = [
            vec_s[v0],
            vec_s[v1],
            vec_s[v2],
            vec_s[v3],
            vec_s[v4],
            vec_s[v5],
            vec_s[v6],
            vec_s[v7]
        ];

        // Recurse iterations
        if (--iterations >= 0) {

            var tmp = [];

            Array.prototype.push.apply(tmp, hilbert3D(vec[0], half, iterations, v0, v3, v4, v7, v6, v5, v2, v1));
            Array.prototype.push.apply(tmp, hilbert3D(vec[1], half, iterations, v0, v7, v6, v1, v2, v5, v4, v3));
            Array.prototype.push.apply(tmp, hilbert3D(vec[2], half, iterations, v0, v7, v6, v1, v2, v5, v4, v3));
            Array.prototype.push.apply(tmp, hilbert3D(vec[3], half, iterations, v2, v3, v0, v1, v6, v7, v4, v5));
            Array.prototype.push.apply(tmp, hilbert3D(vec[4], half, iterations, v2, v3, v0, v1, v6, v7, v4, v5));
            Array.prototype.push.apply(tmp, hilbert3D(vec[5], half, iterations, v4, v3, v2, v5, v6, v1, v0, v7));
            Array.prototype.push.apply(tmp, hilbert3D(vec[6], half, iterations, v4, v3, v2, v5, v6, v1, v0, v7));
            Array.prototype.push.apply(tmp, hilbert3D(vec[7], half, iterations, v6, v5, v2, v1, v0, v3, v4, v7));

            // Return recursive call
            return tmp;

        }

        // Return complete Hilbert Curve.
        return vec;

    }
</script>
<script type="text/javascript">
    let generic = 0x4068F4,         // BLUE
        numericColor = 0x9b42f4,    // ORANGE
        binaryColor = 0xF6B85B,     // GREEN
        textColor = 0x21C156;       // PURPLE
    const xDistanceScale = 1.5;
    const yDistanceScale = 5;

    let geneToMeshMap = {};
    let genomes = [];
    genomes.push(createRandomGenome(25));
    genomes.push(createRandomGenome(25));
    genomes.push(createRandomGenome(25));
    genomes.push(createRandomGenome(25));

    function geneToBox(gene, isActivated, xIndex, yIndex) {
        let color, position = {x: xIndex * xDistanceScale, y: yIndex * yDistanceScale, z: 0},
            geometry = new THREE.BoxGeometry(1, 1, 1, 2, 2, 2);
        switch (gene.type) {
            case "numeric":
                color = numericColor;
                break;
            case "text":
                color = textColor;
                break;
            case "binary":
                color = binaryColor;
                break;
            default:
                color = generic;
                break;
        }

        let material = new THREE.MeshStandardMaterial({color: color, emissive: color});
        let mesh = new THREE.Mesh(geometry, material);

        let spriteMaterial = new THREE.SpriteMaterial({
            map: new THREE.ImageUtils.loadTexture('./glow.png'),
            useScreenCoordinates: false,
            color: color,
            transparent: false,
            blending: THREE.AdditiveBlending
        });

        let sprite = new THREE.Sprite(spriteMaterial);
        sprite.scale.set(1.5, 2, .1);
        sprite.visible = false;
        mesh.add(sprite);

        mesh.position.set(position.x, position.y, position.z);
        return mesh;
    }

    function updateGenome(genome) {
        let activatedGenes = genome.enabledGenes;
        for (let i = 0; i < genome.genes.length; i++) {
            updateGene(genome.genes[i], activatedGenes[i])
        }
    }

    function randomizeValue(gene) {
        switch (gene.type) {
            case 'binary':
                gene._data = Math.random() > 0.5;
                break;
            case 'numeric':
                gene._data = Math.random() * 1000;
                break;
            default:
                gene._data = Math.floor(Math.random() * 1000000).toString();
                break;
        }
    }

    function updateGene(gene, isActivated) {
        // TODO: put this in a meaningful place
        // randomizeValue(gene);
        let yScale = Math.log(1 + (gene.length));
        let mesh = geneToMeshMap[gene];

        let color;
        switch (gene.type) {
            case "numeric":
                color = numericColor;
                break;
            case "text":
                color = textColor;
                break;
            case "binary":
                color = binaryColor;
                break;
            default:
                color = generic;
                break;
        }

        mesh.children[0].visible = isActivated;
        mesh.scale.set(mesh.scale.x, yScale, mesh.scale.z);
    }

    function renderGenome(genome, verticalIndex) {
        let meshes = [];
        for (let i = 0; i < genome.genes.length; i++) {
            let gene = genome.genes[i];
            let mesh = geneToBox(gene, genome.enabledGenes[i], i, verticalIndex);
            meshes.push(mesh);
            geneToMeshMap[gene] = mesh;
        }
        return meshes;
    }

    var windowHalfX = window.innerWidth / 2,
        windowHalfY = window.innerHeight / 2,
        camera, scene, renderer;
    let container = document.createElement('div');
    document.body.appendChild(container);

    init(container);
    animate();

    function init(container) {
        let i;
        camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 1, 10000);
        camera.position.z = 100;
        scene = new THREE.Scene();
        renderer = new THREE.WebGLRenderer();
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        container.appendChild(renderer.domElement);

        for (let i = 0; i < genomes.length; i++) {
            let meshes = renderGenome(genomes[i], i);
            for (let mesh of meshes) {
                scene.add(mesh);
            }
        }

        window.addEventListener('resize', onWindowResize, false);
    }

    function onWindowResize() {
        windowHalfX = window.innerWidth / 2;
        windowHalfY = window.innerHeight / 2;
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
        requestAnimationFrame(animate);
        render();
    }

    function render() {
        camera.lookAt(scene.position);
        // var time = Date.now() * 0.00015;
        // for (var i = 0; i < scene.children.length; i++) {
        //     var object = scene.children[i];
        //     object.rotation.y = time * (i % 2 ? 1 : -1);
        // }
        renderer.render(scene, camera);
        for (let genome of genomes) {
            updateGenome(genome);
            genome.reset();
        }
    }
</script>
</body>
</html>